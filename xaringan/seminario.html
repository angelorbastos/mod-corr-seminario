<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title></title>
    <meta charset="utf-8" />
    <link href="libs/remark-css/chocolate-fonts.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css?family=Abel|Biryani|Yanone+Kaffeesatz&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">


class: center, middle, inverse, title-slide

&lt;h3 style = "font-family: Abel; vertical-align: top;"&gt;UNIVERSIDADE FEDERAL DO RIO GRANDE DO SUL&lt;/h4&gt;

&lt;h1 id="h1-capa"&gt;Seminário:&lt;br/&gt;Modelos de Transição&lt;/h1&gt;

&lt;h1 id="h1-capa"&gt;Modelos para Dados Correlacionados (MAT02035)&lt;/h1&gt;

&lt;h3 style = "font-family: Abel;"&gt;Angelo Rosa, Camila Leuck, Gabriel dos Santos, Raquel Rossi e Vítor Coutinho&lt;/h3&gt;

&lt;h4 style = "font-family: Abel;"&gt;Atualizado em 17 de dezembro de 2019&lt;/h2&gt;

---



# Introdução
Nos estudos de dados longitudinais em que medidas são tomadas repetidamente sobre o mesmo indivíduo ao longo do tempo, há uma variação entre observações registradas entre indivíduos e dentro de um indivíduo.

Quando os estudos são desenvolvidos considerando que a variável resposta não tem distribuição normal, geralmente a metodologia adequada para a análise é usar modelos lineares generalizados (MLGs).

Os modelos de transição ou modelos de Markov, são aqueles nos quais qualquer resposta numa sequência de medidas repetidas é modelada condicionalmente sob um ou mais conjuntos de medições passadas. Basicamente caracterizam-se por apresentar uma relação de dependência da distribuição condicional da resposta atual sobre as respostas anteriores e as variáveis explicativas.
---

# Estimação dos parâmetros do MLG
O método proposto para estimação do vetor de parâmetros `\(\beta\)` foi o da máxima verossimilhança. Considerando uma amostra aleatória de n observações de uma distribuição exponencial


`\(f(y_i,\theta_i,\phi)=exp \{ \frac{1}{a_i(\phi)}[y_i \theta_i - b(\theta_i)]+c(y_i,\phi) \}\)`

A função de verossimilhança é dada por

`\(L( \theta_i , \phi ,y_i) = \prod_{i=1}^{n} f(y_i, \theta_i , \phi ) = exp\{\sum_{i=1}^{n}[ \frac{1}{a_i(\phi)}[y_i \theta_i - b(\theta_i)]+c(y_i,\phi) ]\}\)`

Cujo logaritmo é

`\(l( \theta_i , \phi ,y_i) =\sum_{i=1}^{n}\{ \frac{1}{a_i(\phi)}[y_i \theta_i - b(\theta_i)]+c(y_i,\phi) \}\)`

---

# Estimação dos parâmetros do MLG

Derivando a última função vista no slide passado em relação a `\(\beta_j\)`, obtém-se a função escore

`\(U_j= \frac{\partial l}{\partial \beta_j} = \frac{\partial l}{\partial \theta_i} \frac{\partial \theta_i}{\partial \mu_i} \frac{\partial \mu_i}{\partial \eta_i} \frac{\partial \eta_i}{\partial \beta_j} = \sum_{i=1}^{n} \frac{1}{a_i(\phi)} (y_i - \mu_i) (\frac{\partial \theta_i}{\partial \eta_i}) x_{ij}\)`

Soluções aproximadas podem ser encontradas utilizando método Newton-Raphson ou método escore de Fisher, pelo método de Fisher temos:

`\(\beta^{(m+1)} = (X'W^{(m)}X)^{-1} X'W^{(m)}z^{(m)}\)`

Onde X é a matriz de especificação do modelo e W é a matriz diagonal de pesos.

---

# Análise de resíduos e diagnósticos
As técnicas usadas são as mesmas dos modelos lineares clássicos, com resposta normal, tanto para as técnicas baseadas em testes de hipóteses como para as baseadas em recursos gráficos. Os resíduos mais usuais para análise e diagnósticos dos MLGs são:

1) Resíduos de Pearson generalizados

`\(r_i^{p} = \frac{y_i -\hat{\mu_i}}{\sqrt{\frac{\hat{\phi}}{\omega_i}V(\hat{\mu_i})}}\)`

Em que `\(\hat{\phi}\)` é uma estimativa consistente para o parâmetro de dispersão `\(\phi\)` e `\(\omega_i\)` são presos a priori.

---

# Análise de resíduos e diagnósticos

2) Resíduos de Pearson generalizados padronizados internamente

`\(r_i^{p^i} = \frac{y_i -\hat{\mu_i}}{\sqrt{\frac{\hat{\phi}}{\omega_i}V(\hat{\mu_i})}(1-h_i)}\)`

Através de estudos de simulação de Monte Carlo a distribuição de resíduos não possuí distribuição normal, mesmo para grandes amostras.

---

# Análise de resíduos e diagnósticos

3) Componentes do desvio padronizados internamente

`\(r_i^{D^i} = \frac{r_i^D}{\sqrt{1-h_i}}\)`

É a versão padronizada do desvio abaixo. É o mais utilizado, tendo em vista que dentre todos a distribuição do desvio padronizado é a que mais se aproxima da normal.

`\(r_i^{D} = \pm (y_i - \hat{\mu_i})\sqrt{\frac{2 \hat{\omega_i}}{\hat{\phi}}[y_i(\tilde{\theta_i} - \hat{\theta_i}) - b(\tilde{\theta_i})+b(\hat{\theta_i})]}\)`

---

# Contextualização

---

# Modelos de Transição

---

# Modelando no R

---

# Exemplos

---

# Conclusões

---

# Agradecimentos

---

# Referências Bibliográficas
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
